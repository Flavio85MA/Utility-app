<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Utility-app · Strumenti Video (Sottotitoli)</title>

  <!-- Tailwind CSS (CDN) per uno stile pulito -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- FFmpeg.wasm (CDN) -->
  <!-- Usiamo createFFmpeg + corePath da unpkg: nessun file .wasm nel repo -->
  <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.10.1/dist/ffmpeg.min.js"></script>
</head>
<body class="bg-slate-50 text-slate-800">
  <main class="max-w-3xl mx-auto px-4 py-8">
    <h1 class="text-2xl font-bold mb-1">Strumenti Video — Masterizza Sottotitoli</h1>
    <p class="text-sm text-slate-600 mb-6">
      Carica un <b>video</b> e un file sottotitoli (<code>.srt</code> o <code>.ass</code>).<br/>
      Se hai un <code>.srt</code>, puoi <b>generare un .ass colorato</b> (testo giallo/bianco, contorno, ecc.) e poi masterizzarlo nel video.
      Tutto avviene <i>nel browser</i> (ffmpeg.wasm).
    </p>

    <!-- Selettori file -->
    <div class="grid sm:grid-cols-2 gap-4 mb-4">
      <div>
        <label class="text-sm font-medium">Video</label>
        <input id="videoFile" type="file" accept="video/*"
               class="mt-1 block w-full file:px-3 file:py-2 file:rounded-xl file:border-0 file:bg-slate-800 file:text-white file:text-sm file:cursor-pointer"/>
      </div>
      <div>
        <label class="text-sm font-medium">Sottotitoli (.srt o .ass)</label>
        <input id="subsFile" type="file" accept=".srt,.ass"
               class="mt-1 block w-full file:px-3 file:py-2 file:rounded-xl file:border-0 file:bg-slate-800 file:text-white file:text-sm file:cursor-pointer"/>
      </div>
    </div>

    <!-- Generatore .ASS da .SRT -->
    <div class="bg-white rounded-xl shadow p-4 mb-4 grid sm:grid-cols-3 gap-4">
      <div>
        <label class="text-sm font-medium">Colore testo</label>
        <input id="assColor" type="color" value="#ffd400" class="mt-1 h-10 w-20 rounded"/>
        <p class="text-xs text-slate-500 mt-1">Consigliato: giallo (#ffd400) o bianco (#ffffff)</p>
      </div>
      <div>
        <label class="text-sm font-medium">Dimensione font</label>
        <input id="assFontSize" type="number" value="28" min="10" max="96"
               class="mt-1 w-full border rounded px-3 py-2"/>
      </div>
      <div>
        <label class="text-sm font-medium">Contorno (stroke)</label>
        <input id="assOutline" type="number" value="2" min="0" max="8"
               class="mt-1 w-full border rounded px-3 py-2"/>
      </div>

      <div class="sm:col-span-3">
        <button id="btnMakeAss"
                class="px-4 py-2 rounded-xl bg-slate-900 text-white text-sm hover:opacity-90">
          Se hai un .srt, genera qui un .ass colorato
        </button>
        <span id="assMakeMsg" class="ml-3 text-xs text-slate-500"></span>
      </div>
    </div>

    <!-- Azione principale -->
    <div class="flex items-center gap-3 mb-4">
      <button id="btnBurn"
              class="px-5 py-2 rounded-2xl bg-emerald-600 text-white font-medium hover:opacity-90">
        Masterizza sottotitoli nel video
      </button>
      <span id="videoStatus" class="text-sm text-slate-500"></span>
    </div>

    <!-- Output -->
    <video id="outVideo" controls class="w-full rounded-xl border hidden mb-2"></video>
    <a id="outDownload" download="video_sottotitoli.mp4" class="hidden underline text-sm">Scarica il video</a>

    <details class="mt-6 text-sm text-slate-600">
      <summary class="cursor-pointer font-medium">Note utili</summary>
      <ul class="list-disc pl-5 mt-2 space-y-1">
        <li>Video lunghi possono richiedere tempo: l’elaborazione avviene nel tuo browser.</li>
        <li>Per restare stabile, usa nomi file senza spazi o simboli strani (<code>subs.ass</code>, <code>subs.srt</code>, ecc.).</li>
        <li>Per sottotitoli colorati, usa <code>.ass</code> (o genera l’ASS dal tuo SRT con il pulsante sopra).</li>
      </ul>
    </details>
  </main>

  <script>
    // ------- FFmpeg setup -------
    const { createFFmpeg, fetchFile } = FFmpeg;
    const ffmpeg = createFFmpeg({
      log: true,
      corePath: 'https://unpkg.com/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js',
    });

    // ------- UI refs -------
    const videoFile = document.getElementById('videoFile');
    const subsFile  = document.getElementById('subsFile');
    const btnBurn   = document.getElementById('btnBurn');
    const outVideo  = document.getElementById('outVideo');
    const outDownload = document.getElementById('outDownload');
    const statusEl  = document.getElementById('videoStatus');

    const btnMakeAss = document.getElementById('btnMakeAss');
    const assMakeMsg = document.getElementById('assMakeMsg');
    const assColor   = document.getElementById('assColor');
    const assFontSize= document.getElementById('assFontSize');
    const assOutline = document.getElementById('assOutline');

    let generatedASS = null; // Blob URL del .ass creato da .srt (se usato)

    // ------- Helpers: SRT -> ASS -------
    function rgbToAssHex(rgb) {
      // '#RRGGBB' -> ASS usa &HBBGGRR&
      const r = parseInt(rgb.slice(1,3), 16);
      const g = parseInt(rgb.slice(3,5), 16);
      const b = parseInt(rgb.slice(5,7), 16);
      const hex = (b << 16) | (g << 8) | r;
      return '&H' + hex.toString(16).toUpperCase().padStart(6,'0') + '&';
    }

    function srtToAss(srtText, hexColor, fontSize, outline) {
      const primary = rgbToAssHex(hexColor);
      const outlineColor = '&H000000&';
      const header =
`[Script Info]
ScriptType: v4.00+
PlayResX: 1920
PlayResY: 1080
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,${fontSize},${primary},&H00FFFFFF&,${outlineColor},&H00000000&,0,0,0,0,100,100,0,0,1,${outline},0,2,30,30,40,0

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

      const lines = srtText.replace(/\r/g,'').split('\n');
      let i=0, events=[];
      function toAssTime(t) {
        // "00:00:01,000" -> "0:00:01.00"
        const [h,m,sms] = t.split(':');
        const [s, ms] = sms.split(',');
        const cs = Math.round(parseInt(ms,10)/10);
        return `${parseInt(h,10)}:${m}:${s}.${cs.toString().padStart(2,'0')}`;
      }
      while(i < lines.length) {
        const idx = lines[i++]; // numero riga (ignorato)
        if(!idx) continue;
        const time = lines[i++] || '';
        const match = time.match(/(\d\d:\d\d:\d\d,\d\d\d)\s+-->\s+(\d\d:\d\d:\d\d,\d\d\d)/);
        if(!match) continue;
        const start = toAssTime(match[1]);
        const end   = toAssTime(match[2]);
        let textLines=[];
        while(i < lines.length && lines[i].trim() !== '') {
          textLines.push(lines[i++]);
        }
        i++; // salta riga vuota
        const txt = textLines.join('\\N').replace(/\\{\\.*?\\}/g,'');
        events.push(`Dialogue: 0,${start},${end},Default,,0,0,0,,${txt}`);
      }
      return header + events.join('\n') + '\n';
    }

    btnMakeAss.addEventListener('click', async () => {
      const file = subsFile.files?.[0];
      if(!file) { assMakeMsg.textContent = 'Carica prima un file .srt.'; return; }
      if(!file.name.toLowerCase().endsWith('.srt')) { assMakeMsg.textContent = 'Il generatore funziona solo con .srt.'; return; }
      const srt = await file.text();
      const assText = srtToAss(
        srt,
        assColor.value,
        parseInt(assFontSize.value,10)||28,
        parseInt(assOutline.value,10)||2
      );
      const blob = new Blob([assText], {type:'text/plain'});
      generatedASS = URL.createObjectURL(blob);
      assMakeMsg.textContent = 'Creato .ass colorato (verrà usato automaticamente al prossimo export).';
    });

    // ------- Azione: burn-in -------
    btnBurn.addEventListener('click', async () => {
      const v = videoFile.files?.[0];
      const s = subsFile.files?.[0] || null;
      if(!v) { alert('Seleziona un file video.'); return; }

      statusEl.textContent = 'Caricamento librerie…';
      try {
        if(!ffmpeg.isLoaded()) await ffmpeg.load();

        statusEl.textContent = 'Preparazione file…';
        ffmpeg.FS('writeFile', 'input.mp4', await fetchFile(v));

        let subsName = null;
        if (generatedASS) {
          // se abbiamo generato un .ass dal .srt, usiamo quello
          const res = await fetch(generatedASS);
          const buf = new Uint8Array(await res.arrayBuffer());
          ffmpeg.FS('writeFile', 'subs.ass', buf);
          subsName = 'subs.ass';
        } else if (s) {
          const low = s.name.toLowerCase();
          const name = low.endsWith('.ass') ? 'subs.ass' : 'subs.srt';
          ffmpeg.FS('writeFile', name, await fetchFile(s));
          subsName = name;
        } else {
          alert('Carica un file sottotitoli (.srt o .ass), oppure genera un .ass dal tuo .srt.');
          statusEl.textContent = '';
          return;
        }

        statusEl.textContent = 'Elaborazione video (può richiedere qualche minuto)…';
        await ffmpeg.run(
          '-i','input.mp4',
          '-vf', `subtitles=${subsName}`,
          '-c:a','copy',
          'output.mp4'
        );

        const data = ffmpeg.FS('readFile','output.mp4');
        const blob = new Blob([data.buffer], { type: 'video/mp4' });
        const url = URL.createObjectURL(blob);

        outVideo.src = url;
        outVideo.classList.remove('hidden');
        outDownload.href = url;
        outDownload.classList.remove('hidden');
        statusEl.textContent = 'Fatto!';
      } catch (err) {
        console.error(err);
        statusEl.textContent = 'Errore durante l\'elaborazione. Apri la console del browser per i dettagli.';
      }
    });
  </script>
</body>
</html>
